https://realpython.com/python-requests/


instalacja modułu
(w venv projektu)
$ python -m pip install requests

"""
aside info
https://realpython.com/what-is-pip/
https://realpython.com/python-virtual-environments-a-primer/

python -m pip list

python -m pip show requests


>>> import requests
>>> requests.__version__
"x.y.z"

---------------------
python -m venv venv




The Requests library is the de facto standard for making HTTP requests in Python

terminal


>>> import requests
>>> requests.get("https://api.github.com")
<Response [200]>







>>> import requests
>>> response = requests.get("http://kodpocztowy.intami.pl/api/81-029")
>>> response
<Response [200]>
>>>


>>> type(response)
<class 'requests.models.Response'>


"""


>>> dir(response)
['__attrs__', '__bool__', '__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__enter__', '__eq__', '__exit__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__
nonzero__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__setstate__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__',
'_content', '_content_consumed', '_next',
'apparent_encoding', 'close', 'connection', 'content', 'cookies', 'elapsed', 'encoding', 'headers', 'history', 'is_perma
nent_redirect', 'is_redirect', 'iter_content', 'iter_lines', 'json', 'links', 'next', 'ok', 'raise_for_status', 'raw', 'reason', 'request', 'status_code', 'text', 'url']


>>> response.raw
<urllib3.response.HTTPResponse object at 0x0000023769303B20>

>>> response.status_code
200



if response.status_code == 200:
    print("Success!")
elif response.status_code == 404:
    print("Not Found.")





if response:
    print("Success!")
else:
    raise Exception(f"Non-success status code: {response.status_code}")


 ------------
import requests
from requests.exceptions import HTTPError

URLS = ["https://api.github.com", "https://api.github.com/invalid"]

for url in URLS:
    try:
        response = requests.get(url)
        response.raise_for_status()     #!!!!! raise Error for status_code  400..600
    except HTTPError as http_err:
        print(f"HTTP error occurred: {http_err}")
    except Exception as err:
        print(f"Other error occurred: {err}")
    else:
        print("Success!")



   status_code

   200..399
   204 no content    (oK ale nie ma co treści w body message)
   304 Not Modified

   200 ok
   300 redirect




=================================
Content
Get pobiera content jako ładunek payload

>>> import requests

>>> response = requests.get("https://api.github.com")
>>> response.content
b'{"current_user_url":"https://api.github.com/user", ...}'

>>> type(response.content)
<class 'bytes'>

strumień danych


response.content daj dostep do surowej odpowiedzi bajtowej

a jakoże często konwertujemy dane jako text
istotne jest kodowanie najczęściej jako strumień kodowany w UTF-8




>>> response.text
'{"current_user_url":"https://api.github.com/user", ...}'

>>> type(response.text)
<class 'str'>

Kodowanie z bajtów do tekstu wymaga kontekstu kodowania - w zalezności od kodowania znaków otrzymamy inny tekst

>>> response.encoding = "utf-8"  # Optional: Requests infers this.
>>> response.text
'{"current_user_url":"https://api.github.com/user", ...}'

informacja o kodowaniu znajduje się w nagłówkach odpowiedzi HTTP



----------------
czesto oczekujemy danych w postaci JSON

dla wygody mamy metodę konwertującą tekst na dane json


>>> response.json()
{'current_user_url': 'https://api.github.com/user', ...}

>>> type(response.json())
<class 'dict'>





>>> response.json()
[{'kod': '81-029', 'miejscowosc': 'Gdynia', 'ulica': 'Jabłkowa', 'gmina': 'Gdynia', 'powiat': 'Gdynia', 'wojewodztwo': 'pomorskie', 'numeracja': []}, {'kod': '81-029', 'miejscowosc': 'Gdynia', 'ulica': 'Północna', 'gmina': 'Gdynia', 'powiat': 'Gdynia', 'wojewodztwo': 'pomorskie', 'numeracja': []}, {'kod': '
81-029', 'miejscowosc': 'Gdynia', 'ulica': 'Przemysłowa', 'gmina': 'Gdynia', 'powiat': 'Gdynia', 'wojewodztwo': 'pomorskie', 'numeracja': []}, {'kod': '81-029', 'miejscowosc': 'Gdynia', 'ulica': 'Wiśniowa', 'gmina': 'Gdynia', 'powiat': 'Gdynia', 'wojewodztwo': 'pomorskie', 'numeracja': []}]
>>>
















Headers
====================
>>> import requests

>>> response = requests.get("https://api.github.com")
>>> response.headers
{'Server': 'GitHub.com', 'Date': 'Fri, 01 Mar 2024 11:26:23 GMT', 'Content-Type': 'application/json; charset=utf-8', 'Cache-Control': 'public, max-age=60, s-maxage=60', 'Vary': 'Accept, Accept-Encoding, Accept, X-Requested-With', 'ETag': 'W/"4f825cc84e1c733059d46e76e6df9db557ae5254f9625dfe8e1b09499c449438"'
, 'X-GitHub-Media-Type': 'github.v3; format=json', 'x-github-api-version-selected': '2022-11-28', 'Access-Control-Expose-Headers': 'ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Resource, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted
-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, X-GitHub-SSO, X-GitHub-Request-Id, Deprecation, Sunset', 'Access-Control-Allow-Origin': '*', 'Strict-Transport-Security': 'max-age=31536000; includeSubdomains; preload', 'X-Frame-Options': 'deny', 'X-Content-Type-Options': 'nosniff', 'X-XSS-Protection': '
0', 'Referrer-Policy': 'origin-when-cross-origin, strict-origin-when-cross-origin', 'Content-Security-Policy': "default-src 'none'", 'Content-Encoding': 'gzip', 'X-RateLimit-Limit': '60', 'X-RateLimit-Remaining': '56', 'X-RateLimit-Reset': '1709292968', 'X-RateLimit-Resource': 'core', 'X-RateLimit-Used': '4
', 'Accept-Ranges': 'bytes', 'Content-Length': '510', 'X-GitHub-Request-Id': 'FDF0:2285B5:8398449:8525931:65E1BB5F'}


w nagłowkach wiadomości HTTP znajdują się informacje

>>> response.headers["Content-Type"]
'application/json; charset=utf-8'

informacja o type zawartości BODY wiadomości

i już wiemy ze otrzymaliśmy  komunikat zawierający treść w formacie   aplication/json
jest to tekst zakodowany  w fomacie znakowym UTF-8



specyfikacja definiuje nagłowki jako case-insensitive
więc zachowujemy to w pythonie
dla kompatybilności
(nie do końca wiemy jak nagłówki przekaże server www

>>> response.headers["content-type"]
'application/json; charset=utf-8'


>>> response.headers["conTENT-TYPE"]
'application/json; charset=utf-8'

odczytywanie informacji z dictionary header też jest case-insensitive


----------------------------------
Query String Parameters

wspólny sposób  request pozwala na przekazanie wartości w adresie zapytania GET
za pomoca query string


-------------
import requests

# Search GitHub's repositories for popular Python projects

# adres w przeglądarce www:
# https://api.github.com/search/repositories?q=language:python&sort=stars&order=desc
#zapytanie o zasoby GET

response = requests.get(
    "https://api.github.com/search/repositories",
    params={"q": "language:python", "sort": "stars", "order": "desc"},
)


# Inspect some attributes of the first three repositories
json_response = response.json()
popular_repositories = json_response["items"]
for repo in popular_repositories[:3]:
    print(f"Name: {repo['name']}")
    print(f"Description: {repo['description']}")
    print(f"Stars: {repo['stargazers_count']}")
    print()
-------------

mozemy podać query string w adresie GET
lub w postaci



parametry możemy tez podac jako bytes

>>> requests.get(
...     "https://api.github.com/search/repositories",
...     params=b"q=language:python&sort=stars&order=desc",
... )
<Response [200]>















.........................
cdn


https://realpython.com/tutorials/intermediate/

